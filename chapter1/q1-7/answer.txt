平方根の計算で使った good-enough? テストは、
非常に小さい数の平方根を取るときには効果的でない。
また、実際の計算機では、算術演算はほとんどの場合、限られた精度で実行される。
それでわれわれのテストは非常に大きい数にも不適切である。

小さい数、大きい数の場合、どのようにテストが失敗するかの例を使ってこのことを説明せよ。

good-enough? を実装するもう一つの戦略は、
ある繰返しから次への guess の変化に注目し、
変化が予測値に比べ非常に小さくなった時に止めるのである。

こういう終了テストを使う平方根手続きを設計せよ。
これは小さい数、大きい数に対してうまく動くか。



1. 非常に小さい数の平方根を取るときには効果的でない。
good-enough? のテスト値 0.001 よりも小さな少数を扱う場合、
十分な精度に達していないにもかかわらず、テストが終了してしまう。

例: 0.0000001 の場合 0.0316 が出力されるが
0.0316 ^ 2 => 0.001 であり、十分な精度に達していないにもかかわらず、
テスト値近辺で、計算が終了してしまう。


2. 非常に大きい数にも不適切である
例：90,000,000 の場合 9486.8329 が出力される。
9486.8329^2 => 89,999,943 で近似だが、割と大きい誤差が出る。


3. 上記を正しくテストできる、good-enough? を実装せよ。
good-enough? の前回の guess を prev-guess として、
guess / prev-guess の結果が非常に小さい場合はテストを継続する。
テストが失敗しているときは 0.2~0.3 あたりが出るが、
近似値に近い場合は、かなり 0 に近づく性質がある。

非常に大きい値の場合は、前回と今の guess の変化量自体は大きい。
同様に、非常に小さい場合は、前回と今の guess の変化量自体は小さい。
前回と今の guess の比を見ることで、大小に関わらない変化量に着目できる。



=== 答え

http://community.schemewiki.org/?sicp-ex-1.7

1. 0.001 をテスト値としている場合、それよりも小さな少数 0.0001 では
計算が十分な精度に達していないにもかかわらず、終了してしまう。

2. 非常に大きい値の場合（例：100000000000000 ぐらい）、小さい数字の差が大きすぎて、
いつまで立っても差が 0.001 のテスト値に達することがない。
悪い場合では good-enough? は常に #f を返却し、処理が終わらなくなってしまう。

3. 前回の guess (old-guess) と guess の差が 0 に近い時、十分な精度に達している。
lisp の場合 少数点数と少数点数の等価比較（=）は、
システムが判断可能な精度で比較される（bit 比較ではないということ）ので、
等価比較で十分。
